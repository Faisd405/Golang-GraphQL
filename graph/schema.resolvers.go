package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"graphql-template/graph/model"
	"log"

	"github.com/google/uuid"
)

var users []*model.User
var items []*model.Item

func init() {
	log.Println("Init - Users array to be created")
	users = make([]*model.User, 0)
	users = append(users, &model.User{
		ID:       "1",
		Name:     "Srinivasa",
		Email:    "Ramanujam@gmail.com",
		Username: "Ramanujam",
		Password: "Ramanujam",
	})
	users = append(users, &model.User{
		ID:       "2",
		Name:     "CV",
		Email:    "Raman@gmail.com",
		Username: "Raman",
		Password: "Raman",
	})
	users = append(users, &model.User{
		ID:       "3",
		Name:     "Subrahmanyan",
		Email:    "Chandrasekhar@gmail.com",
		Username: "Chandrasekhar",
		Password: "Chandrasekhar",
	})
	log.Println("Init - Users array has been created")
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUserInput) (*model.User, error) {
	log.Println("Create a new USER")

	user := &model.User{
		ID:       uuid.NewString(),
		Name:     input.Name,
		Username: input.Username,
		Email:    input.Email,
		Password: input.Password,
	}
	users = append(users, user)

	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	log.Println("Update a USER")

	for _, user := range users {
		if user.ID == id {
			if input.Name != nil {
				user.Name = *input.Name
			}
			if input.Username != nil {
				user.Username = *input.Username
			}
			if input.Email != nil {
				user.Email = *input.Email
			}
			if input.Password != nil {
				user.Password = *input.Password
			}
			return user, nil
		}
	}

	return nil, fmt.Errorf("User not found")
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, input model.DeleteUserInput) (*model.User, error) {
	log.Println("Delete a USER")

	for index, user := range users {
		if user.ID == input.ID {
			users = append(users[:index], users[index+1:]...)
			return user, nil
		}
	}

	return nil, fmt.Errorf("User not found")
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.NewItemInput) (*model.Item, error) {
	log.Println("Create a new ITEM")

	item := &model.Item{
		ID:          uuid.NewString(),
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Image:       "https://picsum.photos/200/300",
	}

	items = append(items, item)

	return item, nil
}

// UpdateItem is the resolver for the updateItem field.
func (r *mutationResolver) UpdateItem(ctx context.Context, id string, input model.UpdateItemInput) (*model.Item, error) {
	log.Println("Update a ITEM")

	for _, item := range items {
		if item.ID == id {
			if input.Name != nil {
				item.Name = *input.Name
			}
			if input.Description != nil {
				item.Description = *input.Description
			}
			if input.Price != nil {
				item.Price = *input.Price
			}
			return item, nil
		}
	}

	return nil, fmt.Errorf("Item not found")
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, input model.DeleteItemInput) (*model.Item, error) {
	log.Println("Delete a ITEM")

	for index, item := range items {
		if item.ID == input.ID {
			items = append(items[:index], items[index+1:]...)
			return item, nil
		}
	}

	return nil, fmt.Errorf("Item not found")
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	log.Println("Get all USERS")
	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	log.Println("Get a USER")

	for _, user := range users {
		if user.ID == id {
			return user, nil
		}
	}

	return nil, fmt.Errorf("User not found")
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context) ([]*model.Item, error) {
	log.Println("Get all ITEMS")
	return items, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*model.Item, error) {
	log.Println("Get a ITEM")

	for _, item := range items {
		if item.ID == id {
			return item, nil
		}
	}

	return nil, fmt.Errorf("Item not found")
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
